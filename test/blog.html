<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Nexus - Blog</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Space+Grotesk:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/remixicon@4.5.0/fonts/remixicon.css" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #050833;
      color: #fff;
    }
    .space-grotesk {
      font-family: 'Space Grotesk', sans-serif;
    }
    /* Navigation Styles */
    nav {
      background-color: rgba(5, 8, 51, 0.8);
      backdrop-filter: blur(10px);
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    nav.sticky {
      background-color: rgba(5, 8, 51, 0.95);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    nav a {
      position: relative;
      transition: color 0.3s ease;
    }
    nav a::after {
      content: '';
      position: absolute;
      width: 100%;
      transform: scaleX(0);
      height: 2px;
      bottom: 0;
      left: 0;
      background-color: #00d4ff;
      transform-origin: bottom right;
      transition: transform 0.3s ease-out;
    }
    nav a:hover::after {
      transform: scaleX(1);
      transform-origin: bottom left;
    }
    /* Animations */
    .fade-in {
      opacity: 0;
      transition: opacity 1s ease-in-out;
    }
    .fade-in.visible {
      opacity: 1;
    }
    .slide-up {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
    }
    .slide-up.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .scale-up {
      transform: scale(0.95);
      transition: transform 0.5s ease-in-out;
    }
    .scale-up:hover {
      transform: scale(1);
    }
    /* Blog Cards Styling */
    .card {
      background-color: #1f2937; /* Tailwind gray-800 equivalent */
      padding: 1.5rem;
      border-radius: 0.5rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      cursor: pointer;
      z-index: 1;
    }
    .card:hover {
      transform: scale(1.05) translateY(-5px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
      z-index: 10; /* Ensure the hovered card is on top */
    }
    /* Loading Indicator */
    #posts-loading {
      text-align: center;
      padding: 1rem;
      color: #9ca3af; /* Tailwind gray-400 */
    }
    /* Update the scrolling animation to create a continuous loop */
    @keyframes scroll {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-50%); /* Simplified calculation */
      }
    }

    .scrolling-container {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow: hidden;
      width: 100%;
    }

    /* Left edge blur effect */
    .scrolling-container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 80px;
      height: 100%;
      background: linear-gradient(to right, rgba(5, 8, 51, 0.9), rgba(5, 8, 51, 0));
      z-index: 5;
      pointer-events: none; /* Allow clicking through the overlay */
    }

    /* Right edge blur effect */
    .scrolling-container::after {
      content: "";
      position: absolute;
      top: 0;
      right: 0;
      width: 80px;
      height: 100%;
      background: linear-gradient(to left, rgba(5, 8, 51, 0.9), rgba(5, 8, 51, 0));
      z-index: 5;
      pointer-events: none; /* Allow clicking through the overlay */
    }

    /* Ensure cards stay visible above the base layer but below the blur effect */
    .scrolling-row {
      position: relative;
      z-index: 1;
      display: flex;
      padding: 1rem 0;
      width: max-content; /* Let it grow as needed */
      animation: scroll 30s linear infinite;
    }

    .scrolling-row-content {
      display: flex;
      gap: 1rem;
      flex-shrink: 0; /* Prevent shrinking */
    }

    .scrolling-container .card {
      min-width: 280px;
      flex-shrink: 0; /* Prevent shrinking */
      margin-right: 1rem; /* Add explicit margin between cards */
    }

    /* Add pause on hover for row */
    .scrolling-row:hover {
      animation-play-state: paused;
    }
  </style>
</head>
<body>
  <nav class="fixed w-full p-4 flex justify-between items-center space-grotesk z-10">
    <div class="text-primary text-2xl font-bold">AI Nexus</div>
    <div class="space-x-4">
      <a href="index.html" class="text-white hover:text-primary">Home</a>
      <a href="tools.html" class="text-white hover:text-primary">AI Tools</a>
      <a href="blog.html" class="text-white hover:text-primary">Blog</a>
      <a href="community.html" class="text-white hover:text-primary">Community</a>
      <a href="contact.html" class="text-white hover:text-primary">Contact</a>
    </div>
  </nav>
  <section class="min-h-screen pt-20 pb-16">
    <h1 class="text-4xl font-bold text-center mb-8 space-grotesk fade-in">Latest AI Blog Posts</h1>
    <!-- Infinite Scrolling Grid Section for Blog Cards (no slider) -->
    <div class="container mx-auto scrolling-container" id="posts-container">
      <!-- Dynamically loaded posts will appear here -->
    </div>
    <div id="posts-loading">Loading more posts...</div>
  </section>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Sticky Navbar
      const nav = document.querySelector('nav');
      window.addEventListener('scroll', () => {
        if (window.scrollY > 100) {
          nav.classList.add('sticky');
        } else {
          nav.classList.remove('sticky');
        }
      });
  
      // Intersection Observer for scroll animations
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            console.log('Animating element:', entry.target);
            entry.target.classList.add('visible');
            observer.unobserve(entry.target);
          }
        });
      }, { threshold: 0.1 });
  
      document.querySelectorAll('.fade-in, .slide-up').forEach(el => {
        observer.observe(el);
      });
  
      // Infinite Scroll for Blog Posts (Cards)
      const postsContainer = document.getElementById('posts-container');
      const postsLoading = document.getElementById('posts-loading');
      let postCount = 0;
      const postsBatch = 8; // number of posts per load
      let isLoading = false; // flag to prevent duplicate loads
  
      // Function to create a blog post card
      function createPostCard(id) {
        const card = document.createElement('div');
        card.className = 'card slide-up fade-in scale-up';
        card.innerHTML = `
          <img src="path/to/image${id}.jpg" alt="Blog Post ${id} Image" class="w-full h-48 object-cover mb-4 rounded">
          <h3 class="text-xl font-semibold mb-4">Blog Post ${id}</h3>
          <p class="text-gray-300">Excerpt of Blog Post ${id} that dives into AI insights and trends.</p>
          <a href="#" class="text-primary hover:underline">Read More</a>
        `;
        // Animate card as it scrolls into view
        observer.observe(card);
        return card;
      }
  
      // Function to create a row of scrolling cards with duplicated content for seamless looping
      function createScrollingRow() {
        const row = document.createElement('div');
        row.className = 'scrolling-row';
        
        // First set of cards (original)
        const content1 = document.createElement('div');
        content1.className = 'scrolling-row-content';
        
        // Second set of cards (duplicate for seamless looping)
        const content2 = document.createElement('div');
        content2.className = 'scrolling-row-content';
        
        row.appendChild(content1);
        row.appendChild(content2);
        
        return {
          row: row,
          content1: content1,
          content2: content2
        };
      }
  
      // Function to load more blog cards
      function loadPosts() {
        if (isLoading) return;
        isLoading = true;
        console.log('Loading more posts...');
        // Simulate an API load delay
        setTimeout(() => {
          // Create a new row with containers for original and duplicated content
          const row1Elements = createScrollingRow();
          postsContainer.appendChild(row1Elements.row);
          
          // Create cards for the first row - exactly 4 cards
          const cards1 = [];
          for (let i = 0; i < 4; i++) {
            postCount++;
            const card = createPostCard(postCount);
            row1Elements.content1.appendChild(card);
            // Create an exact clone for the second part
            const cardClone = card.cloneNode(true);
            cards1.push(cardClone);
          }
          
          // Add duplicates to create seamless loop
          cards1.forEach(card => {
            row1Elements.content2.appendChild(card);
          });
          
          // Create a second row with additional cards - exactly 5 cards
          const row2Elements = createScrollingRow();
          postsContainer.appendChild(row2Elements.row);
          
          // Create cards for the second row
          const cards2 = [];
          for (let i = 0; i < 5; i++) {
            postCount++;
            const card = createPostCard(postCount);
            row2Elements.content1.appendChild(card);
            // Create an exact clone for the second part
            const cardClone = card.cloneNode(true);
            cards2.push(cardClone);
          }
          
          // Add duplicates to create seamless loop
          cards2.forEach(card => {
            row2Elements.content2.appendChild(card);
          });
          
          isLoading = false;
          postsLoading.style.display = 'block';
          
          // Make sure the scroll animation works by forcing a reflow
          row1Elements.row.style.animation = 'none';
          row2Elements.row.style.animation = 'none';
          
          // Trigger reflow
          void row1Elements.row.offsetWidth;
          void row2Elements.row.offsetWidth;
          
          // Re-enable animation
          row1Elements.row.style.animation = '';
          row2Elements.row.style.animation = '';
        }, 800);
      }
  
      // Infinite scrolling observer for posts-loading indicator with a lower threshold
      const postsObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            console.log('posts-loading visible, triggering loadPosts.');
            loadPosts();
          }
        });
      }, { threshold: 0.5 });
  
      postsObserver.observe(postsLoading);
  
      // Initially load posts if container is empty
      if (postsContainer.children.length === 0) {
        loadPosts();
      }
    });
  </script>
</body>
</html>